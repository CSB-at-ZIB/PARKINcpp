// Copyright (C) 2010
// ZIB - Zuse Institute Berlin, Germany
//
// first added : 2010-11-04 td
// last changed:
//

#include "GenericMatrixImpl.h"
#include "dlibMatrixImpl.h"
#include "QRconDecomp.h"
#include "QRMoorePenrose.h"

#include "Matrix.h"
#include "Vector.h"

using namespace PARKIN;

///

//-----------------------------------------------------------------------------
Matrix::Matrix() :
    _impl( new dlibMatrixImpl() )
{
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix::Matrix(long m, long n) :
    _impl( new dlibMatrixImpl(m,n) )
{
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix::Matrix(Matrix const& A)
{
    // if (_impl == 0) _impl = new dlibMatrixImpl();
    if (this != &A)
    {
        _impl = new dlibMatrixImpl(); _impl->assign( A.impl() );
    }
}
//-----------------------------------------------------------------------------

Matrix::Matrix(Vector const& v)
{
    // if (_impl == 0) _impl = new dlibMatrixImpl();
    if (this != (Matrix *)&v)
    {
        _impl = new dlibMatrixImpl(); _impl->assign( v.impl() );
    }
}

//-----------------------------------------------------------------------------
Matrix::~Matrix()
{
    delete _impl;
    _impl = 0;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix const&
Matrix::operator= (Matrix const& A)
{
    if (_impl == 0) _impl = new dlibMatrixImpl();
    if (this != &A)
    {
        // delete _impl;
        // _impl = new dlibMatrixImpl(A.nr(),A.nc());
        _impl->assign( A.impl() );
    }
    return *this;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
long
Matrix::nr() const
{
    return _impl->nr();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
long
Matrix::nc() const
{
    return _impl->nc();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real&
Matrix::operator() (long j, long k)
{
    return _impl->at(j,k);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real const&
Matrix::operator() (long j, long k) const
{
    return _impl->at(j,k);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Matrix::t() const
{
    Matrix C;
    C.impl()->transpose( *_impl );
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Matrix::rowm(long j) const
{
    Matrix C;
    C.impl()->rowm( *_impl, j);
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Matrix::rowm(long j1, long j2) const
{
    Matrix C;
    C.impl()->rowm( *_impl, j1,j2);
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector
Matrix::colm(long k) const
{
    Vector v;
    v.impl()->colm( *_impl, k);
    return v;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Matrix::colm(long k1, long k2) const
{
    Matrix C;
    C.impl()->colm( *_impl, k1,k2);
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Matrix::subm(long j1, long j2, long k1, long k2) const
{
    Matrix C;
    C.impl()->subm( *_impl, j1,j2,k1,k2);
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Mref
Matrix::set_rowm(long j)
{
    return Mref( this, j,j,1,nc());
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Mref
Matrix::set_rowm(long j1, long j2)
{
    return Mref( this, j1,j2,1,nc());
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Mref
Matrix::set_colm(long k)
{
    return Mref( this, 1,nr(),k,k);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Mref
Matrix::set_colm(long k1, long k2)
{
    return Mref( this, 1,nr(),k1,k2);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Mref
Matrix::set_subm(long j1, long j2, long k1, long k2)
{
    return Mref( this, j1,j2,k1,k2);
}
//-----------------------------------------------------------------------------

// set/create random matrix
//-----------------------------------------------------------------------------
void
Matrix::randm(long m, long n)
{
    _impl->randm(m,n);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Matrix::zero()
{
    _impl->zero();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Matrix::zeros(long m, long n)
{
    _impl->zeros(m,n);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Matrix::ones(long m, long n)
{
    _impl->ones(m,n);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Matrix::scale_columns(Vector const& v)
{
    _impl->scale_columns( *v.impl() );
}
//-----------------------------------------------------------------------------

// possible nrmtypes so far: "l1", "l2", "inf", "fro"
//-----------------------------------------------------------------------------
Real
Matrix::norm(std::string nrmtype) const
{
    return _impl->norm(nrmtype);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real
Matrix::trace() const
{
    return _impl->trace();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
QRconDecomp
Matrix::factorQRcon(
    long mcon, // = 0,
    long rank, // = 0,
    Real cond, // = 1.0/sqrt(EPMACH)
    int  meth  // = 0               // use Cholesky variant for pseudo-inverse
) const
{
    long minmn = std::min( nr(), nc() );

    if (rank == 0) rank = minmn;
    // if (2*rank < nc()) meth = 1;    // switch to Moore-Penrose pinv variant

    QRconDecomp qr(mcon, rank, cond, meth);

    qr.decompose( *this );
    return qr;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
QRDecomp
Matrix::factorQR(
    long rank, // = 0,
    Real cond, // = 1.0/sqrt(EPMACH)
    int  meth  // = 0               // use Cholesky variant for pseudo-inverse
) const
{
    long minmn = std::min( nr(), nc() );

    if (rank == 0) rank = minmn;
    // if (2*rank < nc()) meth = 1;    // switch to Moore-Penrose pinv variant

    QRDecomp qr(rank, cond, meth);

    qr.decompose( *this );
    return qr;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
GenericMatrixImpl*
Matrix::impl() const
{
    return _impl;
}
//-----------------------------------------------------------------------------


/// ===========================================================================

//-----------------------------------------------------------------------------
std::ostream&
PARKIN::operator<< (std::ostream& os, Matrix const& A)
{
    return A.impl()->put(os);
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator+ (Matrix const& A, Matrix const& B)
{
    Matrix M;
    M.impl()->add( *A.impl(), *B.impl() );
    return M;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator- (Matrix const& A, Matrix const& B)
{
    Matrix M;
    M.impl()->subtract( *A.impl(), *B.impl() );
    return M;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator* (Real const c, Matrix const& A)
{
    Matrix M;
    M.impl()->mult( c, *A.impl() );
    return M;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator* (Matrix const& A, Real const c)
{
    Matrix M;
    M.impl()->mult( *A.impl(), c );
    return M;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator* (Matrix const& A, Matrix const& B)
{
    Matrix M;
    M.impl()->mult( *A.impl(), *B.impl() );
    return M;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::add (Matrix const& A, Matrix const& B)
{
    return A + B;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::subtract (Matrix const& A, Matrix const& B)
{
    return A - B;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::mult (Matrix const& A, Matrix const& B)
{
    return A*B;
}
//-----------------------------------------------------------------------------
