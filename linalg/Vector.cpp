// Copyright (C) 2010
// ZIB - Zuse Institute Berlin, Germany
//
// first added : 2010-11-04 td
// last changed:
//

#include "GenericMatrixImpl.h"
#include "dlibMatrixImpl.h"

#include "Matrix.h"
#include "Vector.h"

using namespace PARKIN;

///

//-----------------------------------------------------------------------------
Vector::Vector() :
    _impl(new dlibMatrixImpl())
{
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector::Vector(long m) :
    _impl(new dlibMatrixImpl(m,1))
{
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector::Vector(std::vector<Real> const& v) :
    _impl(new dlibMatrixImpl(v.size(),1))
{
    typedef std::vector<Real>::const_iterator VecIterConst;
    long j = 1;
    for (VecIterConst it = v.begin(); it != v.end(); ++it)
        _impl->at(j++,1) = *it;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector::Vector(Vector const& v)
{
    // if (_impl == 0) _impl = new dlibMatrixImpl();
    if (this != &v)
    {
        _impl = new dlibMatrixImpl();
        _impl->assign( v.impl() );
    }
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector::~Vector()
{
    delete _impl;
    _impl = 0;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector const&
Vector::operator= (Vector const& v)
{
    if (_impl == 0) _impl = new dlibMatrixImpl();
    if (this != &v) _impl->assign( v.impl() );
    return *this;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
long
Vector::nr() const
{
    return _impl->nr();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
long
Vector::nc() const
{
    return _impl->nc();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real&
Vector::operator() (long j)
{
    return _impl->at(j,1);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real const&
Vector::operator() (long j) const
{
    return _impl->at(j,1);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Vector::t() const
{
    Matrix C;
    C.impl()->transpose( *_impl );
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Matrix
Vector::diag() const
{
    Matrix C;
    C.impl()->diagm( *_impl );
    return C;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector
Vector::row(long j1, long j2) const
{
    Vector w;
    w.impl()->rowm( *_impl, j1,j2);
    return w;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vref
Vector::set_row(long j1, long j2)
{
    // if (_impl == 0) _impl = new dlibMatrixImpl(j2,1);
    return Vref( this, j1,j2);
}
//-----------------------------------------------------------------------------

// set/create random matrix
//-----------------------------------------------------------------------------
void
Vector::rand(long m)
{
    _impl->randm(m,1);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Vector::zero()
{
    _impl->zero();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void Vector::zeros(long m)
{
    _impl->zeros(m,1);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
void
Vector::ones(long m)
{
    _impl->ones(m,1);
}
//-----------------------------------------------------------------------------

// possible nrmtypes so far: "l1", "l2", "inf", "fro"
//-----------------------------------------------------------------------------
Real
Vector::norm(std::string nrmtype) const
{
    if ( nrmtype == "l2" ) nrmtype = "fro";
    return _impl->norm(nrmtype);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//Real
//Vector::length_squared() const
//{
//    return _impl->length_squared();
//}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector
Vector::dotmult(Vector const& v) const
{
    Vector z;
    z.impl()->pointwise_multiply( *_impl, *v.impl() );
    return z;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector
Vector::dotdiv(Vector const& v) const
{
    Vector z;
    z.impl()->pointwise_divide( *_impl, *v.impl() );
    return z;
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
GenericMatrixImpl*
Vector::impl() const
{
    return _impl;
}
//-----------------------------------------------------------------------------

/// =====================================================================

//-----------------------------------------------------------------------------
std::ostream&
PARKIN::operator<< (std::ostream& os, Vector const& v)
{
    return v.impl()->put(os);
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Vector
PARKIN::operator+ (Vector const& v, Vector const& w)
{
    Vector z;
    z.impl()->add( *v.impl(), *w.impl() );
    return z;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Vector
PARKIN::operator- (Vector const& v, Vector const& w)
{
    Vector z;
    z.impl()->subtract( *v.impl(), *w.impl() );
    return z;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Vector
PARKIN::operator* (Real const c, Vector const& v)
{
    Vector w;
    w.impl()->mult( c, *v.impl() );
    return w;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Vector
PARKIN::operator* (Vector const& v, Real const c)
{
    Vector w;
    w.impl()->mult( *v.impl(), c );
    return w;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Vector
PARKIN::operator* (Matrix const& A, Vector const& x)
{
    Vector w;
    w.impl()->mult( *A.impl(), *x.impl() );
    return w;
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Real
PARKIN::operator* (Vector const& v, Vector const& w)
{
    Vector z;
    z = v.t() * w;
    return z(1);
}
//-----------------------------------------------------------------------------

//

//-----------------------------------------------------------------------------
Matrix
PARKIN::operator* (Vector const& v, Matrix const& A)
{
    Matrix C;
    C = v.t() * A;
    return C; // (v.t() * A);
}
//-----------------------------------------------------------------------------

///

//-----------------------------------------------------------------------------
Real
PARKIN::norm(Vector const& v)
{
    return v.impl()->norm("fro");
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Real
PARKIN::length_squared(Vector const& v)
{
    return v.impl()->length_squared();
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
Vector
PARKIN::mult (Matrix const& A, Vector const& x)
{
    return A*x;
}
//-----------------------------------------------------------------------------
